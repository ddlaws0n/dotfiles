#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = ["rich", "pyyaml"]
# ///

"""
1Password Secrets Validation Script

Validates that all secrets defined in .chezmoidata/secrets.yaml are accessible
through the 1Password CLI and that the integration is working correctly.

Usage:
    validate-secrets [--verbose] [--check-env-file]
"""

import argparse
import json
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import yaml
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich import print

console = Console()

class SecretsValidator:
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.chezmoi_dir = Path.home() / ".local/share/chezmoi"
        self.secrets_file = self.chezmoi_dir / "home/.chezmoidata/secrets.yaml"
        self.vaults_file = self.chezmoi_dir / "home/.chezmoidata/vaults.yaml"
        self.env_file = Path.home() / ".local/share/secrets/secrets.env"

    def check_prerequisites(self) -> bool:
        """Check that required tools and files exist."""
        print("\nüîç [blue]Checking Prerequisites[/blue]")

        issues = []

        # Check 1Password CLI
        try:
            result = subprocess.run(['op', '--version'], capture_output=True, text=True)
            if result.returncode == 0:
                print("‚úÖ 1Password CLI installed")
                if self.verbose:
                    print(f"   Version: {result.stdout.strip()}")
            else:
                issues.append("1Password CLI not working properly")
        except FileNotFoundError:
            issues.append("1Password CLI not installed")

        # Check authentication
        try:
            result = subprocess.run(['op', 'account', 'get'], capture_output=True, text=True)
            if result.returncode == 0:
                print("‚úÖ 1Password CLI authenticated")
                if self.verbose:
                    account_info = json.loads(result.stdout)
                    print(f"   Account: {account_info.get('email', 'Unknown')}")
            else:
                issues.append("1Password CLI not authenticated (run 'op signin')")
        except Exception as e:
            issues.append(f"Error checking 1Password authentication: {e}")

        # Check secrets.yaml
        if self.secrets_file.exists():
            print("‚úÖ secrets.yaml file found")
        else:
            issues.append(f"secrets.yaml not found at {self.secrets_file}")

        # Check env file
        if self.env_file.exists():
            print("‚úÖ secrets.env file found")
        else:
            issues.append(f"secrets.env not found at {self.env_file}")
            print("   Run 'chezmoi apply' to generate it")

        if issues:
            print("\n‚ùå [red]Prerequisites Issues:[/red]")
            for issue in issues:
                print(f"   ‚Ä¢ {issue}")
            return False

        return True

    def load_secrets_config(self) -> Tuple[Dict[str, str], Dict[str, str], Dict[str, str]]:
        """Load secrets and vaults configuration."""
        try:
            with open(self.secrets_file, 'r') as f:
                secrets_data = yaml.safe_load(f)
        except Exception as e:
            print(f"‚ùå Error loading secrets.yaml: {e}")
            sys.exit(1)

        vaults_data = {}
        if self.vaults_file.exists():
            try:
                with open(self.vaults_file, 'r') as f:
                    vaults_data = yaml.safe_load(f)
            except Exception as e:
                print(f"‚ö†Ô∏è  Warning: Error loading vaults.yaml: {e}")

        secrets = secrets_data.get('secrets', {})
        work_secrets = secrets_data.get('work_secrets', {})
        vaults = vaults_data.get('vaults', {})

        return secrets, work_secrets, vaults

    def validate_secret_path(self, secret_name: str, secret_path: str) -> Tuple[bool, str]:
        """Validate a single secret path."""
        if not secret_path.startswith('op://'):
            return False, "Invalid format (should start with 'op://')"

        try:
            # Parse the op:// URI
            parts = secret_path.replace('op://', '').split('/')
            if len(parts) < 3:
                return False, "Invalid format (missing vault/item/field)"

            vault_id, item_id, field = parts[0], parts[1], parts[2]

            # Try to read the secret
            cmd = ['op', 'item', 'get', item_id, f'--vault={vault_id}', '--format=json']
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode != 0:
                return False, f"Cannot access item: {result.stderr.strip()}"

            # Check if field exists
            item_data = json.loads(result.stdout)
            fields = {f.get('label', '').lower(): f for f in item_data.get('fields', [])}

            if field.lower() not in fields:
                return False, f"Field '{field}' not found in item"

            return True, "Accessible"

        except Exception as e:
            return False, f"Error: {e}"

    def validate_all_secrets(self) -> None:
        """Validate all secrets defined in secrets.yaml."""
        secrets, work_secrets, vaults = self.load_secrets_config()

        print("\nüîê [blue]Validating Personal Secrets[/blue]")
        self._validate_secret_group(secrets, "Personal")

        if work_secrets:
            print("\nüè¢ [blue]Validating Work Secrets[/blue]")
            self._validate_secret_group(work_secrets, "Work")

    def _validate_secret_group(self, secrets: Dict[str, str], group_name: str) -> None:
        """Validate a group of secrets."""
        if not secrets:
            print(f"   No {group_name.lower()} secrets defined")
            return

        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("Secret Name", style="cyan")
        table.add_column("Status", justify="center")
        table.add_column("Details")

        for secret_name, secret_path in secrets.items():
            if self.verbose:
                print(f"   Checking {secret_name}...")

            is_valid, details = self.validate_secret_path(secret_name, secret_path)

            if is_valid:
                table.add_row(secret_name, "‚úÖ", details)
            else:
                table.add_row(secret_name, "‚ùå", details)

        console.print(table)

    def check_env_file(self) -> None:
        """Check the generated environment file."""
        if not self.env_file.exists():
            print(f"\n‚ùå Environment file not found: {self.env_file}")
            print("Run 'chezmoi apply' to generate it")
            return

        print(f"\nüìÑ [blue]Environment File Analysis[/blue]")

        try:
            with open(self.env_file, 'r') as f:
                content = f.read()

            export_lines = [line for line in content.split('\n') if line.strip().startswith('export ')]

            print(f"   File size: {len(content):,} bytes")
            print(f"   Export statements: {len(export_lines)}")

            if self.verbose:
                print("\n   Exported variables:")
                for line in export_lines:
                    var_name = line.split('=')[0].replace('export ', '').strip()
                    print(f"   ‚Ä¢ {var_name}")

        except Exception as e:
            print(f"‚ùå Error reading environment file: {e}")

    def test_op_run_integration(self) -> None:
        """Test the op run integration."""
        print(f"\nüöÄ [blue]Testing op run Integration[/blue]")

        if not self.env_file.exists():
            print("‚ùå Environment file not found - cannot test op run")
            return

        # Test with a simple command
        test_cmd = ['op', 'run', '--env-file', str(self.env_file), '--', 'env']

        try:
            result = subprocess.run(test_cmd, capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                env_vars = [line for line in result.stdout.split('\n')
                           if any(key in line for key in ['API_KEY', 'GIT_', 'NEO4J_', 'WIZ_'])]

                print(f"‚úÖ op run integration working")
                print(f"   Loaded {len(env_vars)} secret environment variables")

                if self.verbose:
                    print("   Secret variables loaded:")
                    for var in sorted(env_vars):
                        var_name = var.split('=')[0]
                        print(f"   ‚Ä¢ {var_name}")
            else:
                print(f"‚ùå op run failed: {result.stderr}")

        except subprocess.TimeoutExpired:
            print("‚ùå op run test timed out")
        except Exception as e:
            print(f"‚ùå Error testing op run: {e}")


def main():
    parser = argparse.ArgumentParser(description="Validate 1Password secrets integration")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    parser.add_argument("--check-env-file", action="store_true", help="Check environment file details")
    parser.add_argument("--test-op-run", action="store_true", help="Test op run integration")

    args = parser.parse_args()

    print(Panel.fit(
        "[bold blue]1Password Secrets Validation[/bold blue]\n"
        "Validating secret accessibility and integration",
        border_style="blue"
    ))

    validator = SecretsValidator(verbose=args.verbose)

    # Run checks
    if not validator.check_prerequisites():
        sys.exit(1)

    validator.validate_all_secrets()

    if args.check_env_file:
        validator.check_env_file()

    if args.test_op_run:
        validator.test_op_run_integration()

    print(f"\n‚úÖ [green]Validation complete![/green]")
    print(f"üí° [yellow]Tip:[/yellow] Use 'runwithsecrets your-command' to run scripts with secrets")

if __name__ == "__main__":
    main()