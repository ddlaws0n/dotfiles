#!/bin/bash

# Setup GitHub Actions secrets for Claude Code integration
# Version 2.0 - Simplified and improved

set -euo pipefail

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Environment variables expected (set via op run --env-file=~/.local/share/secrets/secrets.env)
# CLAUDE_CODE_APP_ID     - GitHub App ID (numeric)
# CLAUDE_CODE_APP_KEY    - GitHub App private key (RSA or PKCS#8)
# ANTHROPIC_API_KEY      - Anthropic API key (starts with sk-)

# Global variables
REPOSITORY=""
REPOSITORY_FILE=""
USER=""
WITH_WORKFLOW=false
DRY_RUN=false
VERBOSE=false
INTERACTIVE=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${BLUE}‚Ñπ${NC} $1"; }
log_success() { echo -e "${GREEN}‚úÖ${NC} $1"; }
log_warning() { echo -e "${YELLOW}‚ö†${NC} $1"; }
log_error() { echo -e "${RED}‚ùå${NC} $1" >&2; }
log_verbose() { [[ "$VERBOSE" == true ]] && echo -e "${BLUE}üîç${NC} $1"; }

# Generate workflow template
generate_workflow_template() {
    cat << 'EOF'
name: Claude PR Assistant

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude-code-action:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && contains(github.event.issue.body, '@claude'))
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Run Claude PR Action
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.app-token.outputs.token }}
          timeout_minutes: "60"
          # mode: tag  # Default: responds to @claude mentions
          allowed_tools: |
            Bash(just:*)
            Bash(uv:*)
            Bash(git:*)
            Edit
            Write
            MultiEdit
            Read
            Grep
            Glob
            LS
          additional_permissions: |
            actions: read
          # Optional: Restrict network access to specific domains only
          # experimental_allowed_domains: |
          #   .anthropic.com
          #   .github.com
          #   api.github.com
          #   .githubusercontent.com
          #   bun.sh
          #   registry.npmjs.org
          #   .blob.core.windows.net
EOF
}

show_help() {
    cat << EOF
Usage: op run --env-file=~/.local/share/secrets/secrets.env -- $0 [OPTIONS]

Setup GitHub Actions secrets for Claude Code integration

IMPORTANT: This script must be run with 'op run' to securely inject secrets
from your chezmoi-managed secrets.env file.

Prerequisites:
  - 1Password CLI (op) must be installed and authenticated
  - Secrets must be configured in secrets.env (generated by chezmoi apply)
  - GitHub App credentials must be stored in 1Password 'Dev' vault
  - For --with-workflow: GitHub CLI (gh) must be authenticated

Required Secrets (via secrets.env):
  - CLAUDE_CODE_APP_ID: GitHub App ID (numeric)
  - CLAUDE_CODE_APP_KEY: GitHub App private key (RSA or PKCS#8)
  - ANTHROPIC_API_KEY: Anthropic API key (starts with sk-)

Options:
  -r, --repository REPO     Target repository (owner/repo or repo format)
  -f, --file FILE          Process multiple repositories from file (one per line)
  -u, --user USERNAME      Override default user/org for repositories without owner
  -w, --with-workflow      Also create PR with Claude workflow file
  -n, --dry-run           Show what would be done without making changes
  -i, --interactive       Interactive mode with confirmations
  -v, --verbose           Show detailed output
  --validate              Only validate prerequisites and configuration
  --undo                  Remove Claude Code secrets from repository
  -h, --help              Show this help message

Examples:
  op run --env-file=secrets.env -- $0 --repository myorg/myrepo
  op run --env-file=secrets.env -- $0 -r gh-manager
  op run --env-file=secrets.env -- $0 --file repos.txt
  op run --env-file=secrets.env -- $0 --with-workflow --dry-run
  op run --env-file=secrets.env -- $0 --interactive

Setup:
  1. Run 'chezmoi apply' to generate secrets.env from template
  2. Use 'op run --env-file=secrets.env -- setup-cc' for all operations

File format (repos.txt):
  my-repo-1
  dlawson/my-repo-2
  another-repo
EOF
}

# Prerequisites validation
validate_prerequisites() {
    log_info "Validating prerequisites..."

    # Check 1Password CLI
    if ! command -v op &> /dev/null; then
        log_error "1Password CLI (op) is not installed"
        log_error "Install from: https://developer.1password.com/docs/cli/get-started"
        return 1
    fi

    # Check 1Password authentication
    if ! op account list &> /dev/null; then
        log_error "1Password CLI is not authenticated"
        log_error "Run: op signin"
        return 1
    fi

    # Check GitHub CLI for workflow operations
    if [[ "$WITH_WORKFLOW" == true ]] && ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is required for --with-workflow"
        log_error "Install from: https://cli.github.com/"
        return 1
    fi

    if [[ "$WITH_WORKFLOW" == true ]] && ! gh auth status &> /dev/null; then
        log_error "GitHub CLI is not authenticated"
        log_error "Run: gh auth login"
        return 1
    fi


    log_success "Prerequisites validated"
    return 0
}

# Load and validate secrets from environment
load_secrets() {
    log_info "Loading secrets from environment..."

    # Check that all required environment variables are set
    if [[ -z "$CLAUDE_CODE_APP_ID" ]]; then
        log_error "CLAUDE_CODE_APP_ID environment variable not set"
        log_error "Ensure you're running with: op run --env-file=secrets.env -- setup-cc"
        return 1
    fi

    if [[ -z "$CLAUDE_CODE_APP_KEY" ]]; then
        log_error "CLAUDE_CODE_APP_KEY environment variable not set"
        log_error "Ensure you're running with: op run --env-file=secrets.env -- setup-cc"
        return 1
    fi

    if [[ -z "$ANTHROPIC_API_KEY" ]]; then
        log_error "ANTHROPIC_API_KEY environment variable not set"
        log_error "Ensure you're running with: op run --env-file=secrets.env -- setup-cc"
        return 1
    fi

    log_verbose "All required environment variables are set"

    # Validate secret formats
    if [[ ! "$CLAUDE_CODE_APP_ID" =~ ^[0-9]+$ ]]; then
        log_error "Invalid GitHub App ID format (should be numeric)"
        return 1
    fi

    # Convert RSA private key to PKCS#8 format if needed
    if [[ "$CLAUDE_CODE_APP_KEY" =~ ^-----BEGIN\ RSA\ PRIVATE\ KEY----- ]]; then
        log_verbose "Converting RSA private key to PKCS#8 format..."
        # First, properly format the key with line breaks if it's on one line
        if [[ ! "$CLAUDE_CODE_APP_KEY" =~ $'\n' ]]; then
            log_verbose "Reformatting single-line RSA key..."
            # Extract the base64 content between the headers
            local key_content
            key_content=$(echo "$CLAUDE_CODE_APP_KEY" | sed 's/-----BEGIN RSA PRIVATE KEY----- //; s/ -----END RSA PRIVATE KEY-----//')
            # Reformat with proper line breaks (64 chars per line is standard)
            CLAUDE_CODE_APP_KEY="-----BEGIN RSA PRIVATE KEY-----"$'\n'$(echo "$key_content" | fold -w 64)$'\n'"-----END RSA PRIVATE KEY-----"
        fi

        if CLAUDE_CODE_APP_KEY=$(echo "$CLAUDE_CODE_APP_KEY" | openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt 2>/dev/null); then
            log_verbose "Key conversion successful"
        else
            log_error "Failed to convert RSA private key to PKCS#8 format"
            return 1
        fi
    elif [[ ! "$CLAUDE_CODE_APP_KEY" =~ ^-----BEGIN\ PRIVATE\ KEY----- ]]; then
        log_error "Invalid private key format (should be RSA or PKCS#8)"
        return 1
    fi

    if [[ ! "$ANTHROPIC_API_KEY" =~ ^sk- ]]; then
        log_error "Invalid Anthropic API key format (should start with 'sk-')"
        return 1
    fi

    log_success "All secrets loaded and validated"
    return 0
}

# Get current GitHub user with caching
get_current_user() {
    if [[ -n "$USER" ]]; then
        echo "$USER"
        return 0
    fi

    log_verbose "Fetching current GitHub user..."
    if USER=$(gh api user --jq '.login' 2>/dev/null) && [[ -n "$USER" ]]; then
        log_verbose "Current GitHub user: $USER"
        echo "$USER"
        return 0
    fi

    log_error "Could not determine current GitHub user"
    log_error "Please specify --user or ensure you're authenticated with gh CLI"
    return 1
}

# Normalize repository name (always use current user as default)
normalize_repo_name() {
    local repo="$1"
    if [[ "$repo" == */* ]]; then
        echo "$repo"
    else
        local current_user
        if current_user=$(get_current_user 2>/dev/null); then
            echo "$current_user/$repo"
        else
            return 1
        fi
    fi
}

# Setup secrets for a single repository with transaction-like behavior
setup_secrets_for_repo() {
    local repo="$1"
    local repo_flag="--repo $repo"

    log_info "Setting up secrets for repository: $repo"

    if [[ "$DRY_RUN" == true ]]; then
        log_info "[DRY RUN] Would set the following secrets:"
        log_info "  - APP_ID: ${CLAUDE_CODE_APP_ID:0:6}..."
        log_info "  - APP_PRIVATE_KEY: (RSA key)"
        log_info "  - ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY:0:6}..."
        if [[ "$WITH_WORKFLOW" == true ]]; then
            log_info "[DRY RUN] Would create workflow PR"
        fi
        return 0
    fi

    # Interactive confirmation
    if [[ "$INTERACTIVE" == true ]]; then
        echo -n "Set secrets for $repo? [y/N]: "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_warning "Skipped $repo"
            return 0
        fi
    fi

    # Set secrets with error tracking
    local failed_secrets=()

    log_verbose "Setting APP_ID secret..."
    if ! gh secret set APP_ID --body "$CLAUDE_CODE_APP_ID" $repo_flag 2>/dev/null; then
        failed_secrets+=("APP_ID")
    fi

    log_verbose "Setting APP_PRIVATE_KEY secret..."
    if ! echo "$CLAUDE_CODE_APP_KEY" | gh secret set APP_PRIVATE_KEY $repo_flag 2>/dev/null; then
        failed_secrets+=("APP_PRIVATE_KEY")
    fi

    log_verbose "Setting ANTHROPIC_API_KEY secret..."
    if ! gh secret set ANTHROPIC_API_KEY --body "$ANTHROPIC_API_KEY" $repo_flag 2>/dev/null; then
        failed_secrets+=("ANTHROPIC_API_KEY")
    fi

    # Handle failures
    if [[ ${#failed_secrets[@]} -gt 0 ]]; then
        log_error "Failed to set secrets for $repo: ${failed_secrets[*]}"
        log_error "You may need to check repository permissions or try again"
        return 1
    fi

    log_success "Secrets configured for $repo"

    # Create workflow PR if requested
    if [[ "$WITH_WORKFLOW" == true ]]; then
        if create_workflow_pr "$repo"; then
            log_success "Workflow PR created for $repo"
        else
            log_error "Workflow PR creation failed for $repo"
            return 1
        fi
    fi

    return 0
}

# Create workflow PR with better error handling
create_workflow_pr() {
    local repo="$1"
    local timestamp=$(date +%s)
    local branch_name="claude-workflow-$timestamp"

    log_verbose "Creating workflow PR for $repo..."

    # Determine default branch
    local default_branch
    if gh api repos/"$repo"/git/refs/heads/main &> /dev/null; then
        default_branch="main"
    elif gh api repos/"$repo"/git/refs/heads/master &> /dev/null; then
        default_branch="master"
    else
        log_error "Could not determine default branch for $repo"
        return 1
    fi

    # Create branch and workflow file
    local default_sha
    default_sha=$(gh api repos/"$repo"/git/refs/heads/"$default_branch" --jq .object.sha)

    if ! gh api repos/"$repo"/git/refs \
        --method POST \
        --field ref="refs/heads/$branch_name" \
        --field sha="$default_sha" &> /dev/null; then
        log_error "Failed to create branch $branch_name"
        return 1
    fi

    # Upload workflow file
    local encoded_content
    encoded_content=$(generate_workflow_template | base64 | tr -d '\n')

    if ! gh api repos/"$repo"/contents/.github/workflows/claude.yml \
        --method PUT \
        --field message="Add Claude Code workflow" \
        --field content="$encoded_content" \
        --field branch="$branch_name" &> /dev/null; then
        log_error "Failed to create workflow file"
        return 1
    fi

    # Create PR
    local pr_url
    if pr_url=$(gh pr create \
        --repo "$repo" \
        --head "$branch_name" \
        --base "$default_branch" \
        --title "Add Claude Code workflow for automated assistance" \
        --body "This PR adds a GitHub Actions workflow that enables @claude mentions in issues and pull requests." 2>/dev/null); then
        log_success "PR created: $pr_url"
        return 0
    else
        log_error "Failed to create pull request"
        return 1
    fi
}

# Parse command line arguments (simplified)
while [[ $# -gt 0 ]]; do
    case $1 in
        -r|--repository) REPOSITORY="$2"; shift 2 ;;
        -f|--file) REPOSITORY_FILE="$2"; shift 2 ;;
        -u|--user) USER="$2"; shift 2 ;;
        -w|--with-workflow) WITH_WORKFLOW=true; shift ;;
        -n|--dry-run) DRY_RUN=true; shift ;;
        -i|--interactive) INTERACTIVE=true; shift ;;
        -v|--verbose) VERBOSE=true; shift ;;
        --validate) validate_prerequisites; exit $? ;;
        --undo) log_error "Undo functionality not yet implemented"; exit 1 ;;
        -h|--help) show_help; exit 0 ;;
        *) log_error "Unknown option: $1"; show_help; exit 1 ;;
    esac
done

# Main execution
main() {
    # Validate prerequisites
    if ! validate_prerequisites; then
        exit 1
    fi

    # Load secrets
    if ! load_secrets; then
        exit 1
    fi

    # Determine execution mode
    if [[ -n "$REPOSITORY_FILE" ]]; then
        # Batch mode
        if [[ ! -f "$REPOSITORY_FILE" ]]; then
            log_error "Repository file not found: $REPOSITORY_FILE"
            exit 1
        fi

        log_info "Processing repositories from file: $REPOSITORY_FILE"

        local failed_repos=() success_count=0 total_count=0

        while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Trim whitespace
            local repo
            repo=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            [[ -z "$repo" ]] && continue

            # Normalize repository name
            local normalized_repo
            if normalized_repo=$(normalize_repo_name "$repo"); then
                total_count=$((total_count + 1))
                if setup_secrets_for_repo "$normalized_repo"; then
                    success_count=$((success_count + 1))
                else
                    failed_repos+=("$normalized_repo")
                fi
            else
                failed_repos+=("$repo")
            fi
        done < "$REPOSITORY_FILE"

        # Summary
        log_info "Summary: $success_count/$total_count repositories processed successfully"
        if [[ ${#failed_repos[@]} -gt 0 ]]; then
            log_error "Failed repositories: ${failed_repos[*]}"
            exit 1
        else
            log_success "All repositories processed successfully!"
        fi

    elif [[ -n "$REPOSITORY" ]]; then
        # Single repository mode
        local normalized_repo
        if normalized_repo=$(normalize_repo_name "$REPOSITORY"); then
            if setup_secrets_for_repo "$normalized_repo"; then
                log_success "Setup complete for $normalized_repo"
            else
                exit 1
            fi
        else
            exit 1
        fi

    else
        # Current repository mode
        if ! git rev-parse --git-dir > /dev/null 2>&1; then
            log_error "Not in a git repository. Please specify a repository with --repository"
            exit 1
        fi

        local current_repo
        if current_repo=$(gh repo view --json nameWithOwner --jq .nameWithOwner 2>/dev/null); then
            if setup_secrets_for_repo "$current_repo"; then
                log_success "Setup complete for current repository: $current_repo"
            else
                exit 1
            fi
        else
            log_error "Could not determine current repository name"
            exit 1
        fi
    fi
}

# Run main function
main "$@"